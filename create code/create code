#include <kipr/wombat.h>
int rmotor = 200;              //right motor speed value that makes robot go straight
int lmotor = 208;              //left motor speed value that makes robot go straight
int open = 568;                //open scoop servo value, large enough to grab firewall
int close = 1510;              //close scoop servo value, small enough to secure firewall
int up = 1700;                 //raised scoop value, high enough to reach alarm switch
int down = 1020;                //lowered scoop value, almost touching ground
int armstart = 1250;           //starting servo position for arm
int poms = 20;                 //drop off pom distance in cm
int line = 37.6;               //distance to back up to line
int arm = 2;                   //arm servo port
int claw = 0;                  //claw servo port
int scoop = 3;                 //pom scoop servo port
int rise = 1600;               //up value for pom scoop
int low = 250;                 //down value for pom scoop to pick up poms
void rturn (int degrees);      //turn right for inputted number of degrees
void lturn (int degrees);      //turn left for inputted number of degrees
void fdrive (int distance);    //drive forward for an inputted distance in cm
void bdrive (int distance);    //drive backward for an inputted distance in cm
void zoom (int distance);      //drive forward at highest speed for inputted distance in cm

int main()
{
wait_for_light(0);
shut_down_in(120);
create_connect();
enable_servos ();
set_servo_position (scoop, low);        //lowers scoop
    set_servo_position (arm, up);     //lowers arm
    set_servo_position (claw, open);    //opens claw
msleep(300);
/*zoom(30);                               //try no knock down rack-a-stack with momentum
    msleep(100);
    set_servo_position (arm, up);       //moves arm out of the way
  */  fdrive(175);                        //moves to last set of files
rturn(110);                             //turn right 110 degrees
msleep(200);                            //pause for half a second
bdrive(20);
//set_servo_position (scoop, 790);       //raises scoop a bit
//rturn(70);                            //turns to knock down rack-a-stack
  //PUT A DRIVE HEREE
// lturn(135);                           //turns to face cube
    //CUBEEEEEE
/*set_servo_position (claw, open);      //open scoop
set_servo_position (arm, down);       //lower scoop
fdrive (firewall);                    //drive towards cube
msleep(500);
set_servo_position (claw, secure);    //close scoop to grab firewall
msleep(500);
bdrive (firewall);                    //drive backwards to the line
set_servo_position (arm, up);       //lift the firewall off the ground
rturn (130);                          //turns right 135 degrees to face external network connection
fdrive (150);                          //drives to external network connection
set_servo_position (arm, down);       //puts arm down
    msleep(500);
fdrive (20);                          //drives to external network connection
set_servo_position (claw, open);      //lets go of cube under connection
bdrive (20);                          //drives backward
    */
/*lturn(20);                            //turn left 45 degrees, should be perpendicular with line
bdrive(line);                           //backs up to black line
lturn(90);                              //turn left 90 degrees, should be parallel with line
bdrive(20);
    //SLAYYYYY
set_servo_position (claw, close);       //close scoop
set_servo_position (arm, armstart);     //lower/raise scoop
msleep(1000); 
fdrive(37);
set_servo_position (arm, up);          //raise scoop to flip alarm
msleep(1000);
bdrive (20);
rturn (45);
set_servo_position (claw, open);       //open scoop
set_servo_position (arm, down);        //lower arm
*/
disable_servos ();
create_stop();
create_disconnect();
return(0);
}

void rturn (int degrees)
{
create_drive_direct (lmotor, -rmotor);
msleep(degrees*10.43);                     
create_stop();
}

void lturn (int degrees)
{
create_drive_direct (-lmotor, rmotor);
msleep(degrees*10.43);                   
create_stop();
}

void fdrive (int distance)
{
create_drive_direct(lmotor, rmotor);
msleep(distance/19*1000);           
create_stop();
}

void bdrive (int distance)
{
create_drive_direct(-lmotor, -rmotor);
msleep(distance/19*1000);           
create_stop();
}

void zoom (int distance)
{
create_drive_direct(500, 500);
msleep(distance/16*1000);           
create_stop();
}
